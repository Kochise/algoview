Development Document about version 0.3

From JD.Rhee

---------------------------------------------------------
Basically Algoview supports C .

And it can read partially C++ and assembly language
(Intel grammar and AT&T grammar(*.asm or *.s)).

Currently it's performance is basic and has rooms for improvment.

Frankly,I think Algoview's source codes have many things to be improved,

it is too complex,and I have had a plan to modify it largely.

---------------------------------------------------------------------

And English is a foreign language to me ,not my mother tongue.

So there may be strange expressions in text and I seek your understanding 
about this.

----------------------------------------------------------------------
About Algoview Source File Structure:

1.Algoview has largely two parts(frontend and backend).

(1).frontend (language dependent part which read source file and generates 
a xml-like internal text file(view.tmp file).)
	lex.h
	lex.c  : C Lexical Analyizer being called by routines in parser.c.

	parser.h
	parser.c : C Parser that reads C source file and generates the internal text file. 

	asmparse.h
	asmparse.c : Assembly Parser that reads Assembly file and generates the internal xml-like text file.

(2).backend (viewer part that reads the xml-like internal text file and display it in screen.)
	fbox.h
	fbox.c: fbox is a data structure  that displayed as a box in screen.
		fbox_read_file() in fbox.c reads the xml-like internal 
		text file which was generated by frontend 
		makes fbox list.
		And it calls another lexical anayzer in fbox.c.

	common.h
	common.c: Allegro library interface and some utilities(queue ,etc...).

	mygui.h
	mygui.c: has viewer's menu procedures.

	viewer.h
	viewer.c: viewer.c has main() funtion.
		  viewer.c is the center of algoview.
		  viewer.c determines fbox's position values in screen.
		  and generates edge data that connect between two boxes.
		  
		  And it has dialogue procedures.
		  These need to be categorized into mygui.c .
(3).misc
	sml.h : Sml.h is a simple macro library that supports 
	        simple linked list and dynamic array.
		Both frontend and backend have linked lists or dynamic arrays 
		using sml.h.
		But this library isn't optimum.
		I have wanted to modify this part.
		If you need linked list or dynamic array,I don't suggest using sml.h. 
		
2. The format of my internal xml-like text file (view.tmp)
	view.tmp's format is not XML.
	It's important limitation is that it can't be hierarchical.
	for example,
	<tag1...>
	...
	<tag2...>
	...
	</tag2>
	</tag1>
	is not allowed.
	Only 
	<tag1...>
	...
	</tag1>
	<tag2...>
	...
	</tag2>
	is allowed.

	(1)statement tag
		<statement id next_id x y linenum >
		multiple_line_texts....
		</statement [attribute] >

		id is current box's id number;
		next_id is next box's id number;
			An edge is formed by id and next_id. 	
		
		x and y represent the position of box.
		
		Warning: 
			Both x and y are not values in screen.
			Position in screen should be calculated 
			in consideration of font size.
			But these are independant of font.
			For examle,
				if you set the first box in x=1 and y=1,
				then you maybe be expected to set the second box
				in in x=1 and y=2.
				Usually the subtraction between two adjcent boxes's xy values 
				is 1.
				So they indicate simply the order in x and y.
		multiple_line_texts are the texts in a box. 
		Attribute in </statement> is optional and can have one of the following things
			global :indicates the box is in global area in C language.
				and means that this doesn't flow.
			function :indicates function definition in C language.
				and added in function index list.
				("go to function" in menu).
	(2)branch tag
		<branch id true_id false_id x y  linenum >
		multiple_line_texts....
		</branch >
		Branch is conditional jump.
		true_id is the box id of true jump.
		false_id is the box id of false jump.
		The rest is the same in statement tag.

3.Outline of Flow of Control
	main() calls the procedure of initilaizing allegro library.
	And initializes menus.
	And calls process().
	process() is the center of viewer.
	In process() keyboard and mouse inputs are processed 
	and the screen is dispayed.

4.Data structure

typedef struct _fbox{
	struct _fbox	*next,*prev;	//next and previous in linked list 
	char *s;			// text
	int id;				// box id
	unsigned int is_function:1;	// is start of function definition?
	struct _fbox	*t;	//true jump box in <branch> or next box in <statement>
	struct _fbox	*f;	//false jump box in <branch>
	struct _fbox	*p;	//previous box (used by "previous statement" item in menu) 
	//(the opposite of next box in <statement> or true jump box in <branch>)  
	int	x;	// x order number
	int	y;	// y order number
	int	a1;	// id of true jumped box in <branch> or next box in <statement>
	int	a2;	// id of false jumped box in <branch>
	int	cx;	
	int	cy;	// cx,cy indicate the certer of the box in screen.
	int cnt;
}fbox;

 And the position of the box in screen is caculated at draw_fbox() in viewer.c as
	screen_x=fbox.x*box_width-sx;
	screen_y=y_sy[fbox.y]-sy;

	(sx,sy indicate scroll position in screen.
	box_width is fixed value that indicates the width of box in screen.
	)

5.Modification of Sources.
(1)Modification of frontend.
	You build a independent parser and 
	make it output internal text file format.
	And modify menu_open() in mygui.c.
  ============== menu_open() in mygui.c =============================================
	change_ext(filename,".c",path);
--->	if(file_select_ex("load",path,"c;C;cc;cpp;CC;CPP;asm;s;S;ASM",511,SCREEN_W*2/3, SCREEN_H*2/3)==0)return 0;
//Modify: replace with following one.
//if(file_select_ex("load",path,"your_new_file_extension;c;C;cc;cpp;CC;CPP;asm;s;S;ASM",511,SCREEN_W*2/3, SCREEN_H*2/3)==0)return 0;

	unload();

	fp=fopen(path,"rt");
	tmpfp=fopen("view.tmp","wt");
	if(fp==0){
		printf("read failed\n");
		return 0;
	}
	ext=get_ext(path);
	if(!strcmp(ext,"s")||!strcmp(ext,"S")||!strcmp(ext,"asm")||!strcmp(ext,"ASM")){
		asm_parser(fp);
	}
/*
Modify : Insert following lines.
else if(!strcmp(ext,"your_new_file_extension")){
		your_parse_and_generate_internal_file(fp);
	}
*/	
	else{
		init_parser(fp);
		get_token();
		parser();
		if(else_if_found){
			sprintf(s,"#else or #elif found at %d!",else_if_found);
			alert("ERROR", s,"This means it can be mis-read.", "Yes",0, 0, 0);	
		}
	}
	...
  ============================================================================
(2)Modification of internal text file format
	If this part modified,
	C parser and Assembly parser already in Algoview must be changed.
	This requires modification of nearly all frontend functions.
	And fbox_read_file() in fbox.c must be modified.
-------------------------------------------------------------------------
